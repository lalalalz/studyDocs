# 알고리즘 (완전탐색)

## 1. 개요
### 1.1. 완전탐색이란?
--------------------------------------------------------------------------------
  완전탐색(brute force)이란 가장 간단한 알고리즘 설계방식으로 모든 경우의 수를 실행하여 원하는 답을 찾는 것을 의미한다. 컴퓨터의 빠른 계산 능력을 이용해 가능한 경우의 수를 일일이 나열하면서 답을 찾는 것이다.

  완전탐색은 다른 알고리즘 설계법에 토대가 되는 설계법이다. 그리고 단순한 문제를 어렵게 푸는 실수를 줄이기 위해 가장 먼저 고려되어야 할 알고리즘 설계법이다. 


## 2. 재귀함수

### 2.1. 개요
--------------------------------------------------------------------------------
  하나의  큰 문제는 여러 개의 작은 문제로 나누어 생각할 수 있다. 그리고 많은 경우는 나누어진 작은 문제들이 유사한 형태를 갖는다. 그 중 하나의 작은 문제를 자신이 직접 해결하고, 남은 작은 문제들은 자기 자신을 호출하여 해결하도록 하는 것이 재귀함수이다. 


### 2.2. 문제의 분할
--------------------------------------------------------------------------------
  아래의 코드는 1 부터 n 까지의 합을 구하는 과정을 재귀함수를 이용하여 해결한 것이다. 

``` c

	// 1부터 n까지 합을 구하는 재귀함수
	int recursive(int n)
	{
		if(n == 1)  return 1;
		return recursive(n - 1) + n;
	}

```
  1부터 n까지의 합을 구하는 큰 문제는 n개의 조각으로 나눌 수 있다. 즉, 더할 각 숫자를 하나의 조각이 되도록 한다. 그리고 하나의 조각은 자신이 해결하고 나머지 조각은 재귀형태로 해결한다. 이 내용을 코드로 구현한 것이 바로 위의 코드이다. 

  recursive 함수의 두번째 줄이 큰 문제를 쪼개어 하나의 조각은 자신이 해결하고, 나머지 조각은 재귀형태로 해결하는 것을 구현한 것이다. 


### 2.3. 기저사례 선택
--------------------------------------------------------------------------------
  문제를 계속해 쪼개면, 더 이상 쪼개지지 않는 상황이 발생한다. 위의 문제에서는 1이 그 상황을 의미한다. 1이라는 조각은 더 이상 쪼개지지 않는다. 그 이유는 1 ~ n 까지의 합을 구하는 문제를 n조각으로 나누었기 때문이다. 이처럼 더 이상 쪼개지지 않는 가장 작은 조각을 가리켜 기저사례라고 한다. 

  recursive 함수의 첫번째 줄이 기저사례를 코드로 나타낸 것이다. 기저사례가 없다면 이 함수는 무한히 반복하여 자신을 호출할 것이다. 


## 3. 재귀함수를 이용한 완전탐색

### 3.1. 재귀함수와 완전탐색
--------------------------------------------------------------------------------
  위에서 언급했듯이 완전탐색의 많은 경우도 유사한 형태의 작은 문제로 나누어 생각해 볼 수 있다. 그렇다면 완전탐색의 문제도 재귀함수를 이용해 구현할 수 있음을 의미한다. 

### 3.2. n명을 줄 세우는 경우의 수
--------------------------------------------------------------------------------
  n명을 줄 세울 수 있는 경우는 총 몇가지나 될까? 이 문제를 해결하기 위해 완전탐색을 이용해 모든 경우의 수를 만들어 본 뒤 총 경우의 수를 구해보자. 그 전에 이 문제가 유사한 형태의 작은문제로 쪼개어 질 수 있는지 생각해보자. 

  n명을 줄 세우는 문제는 첫번째 자리에 한명을 앉히고, 두번째 자리에 또 한명을 앉히고, 세번째도 네번째도... 이와 같이 유사한 선택들의 문제들로 나누어질 수 있다. 그리고 그렇게 나누어질 수 있는 문제는 재귀함수의 형태로 해결할 수 있음을 의미한다고 했다. 다음의 코드를 살펴보자.

``` C

	// n의 최댓값
	#define MAX 10
	
	// i번째 사람이 이미 사용됐다면 true
	// i번째 사람이 아직 사용되지 않았다면 false
	bool visited[MAX];
	
	// n명의 사람을 나열할 수 있는 모든 경우의 수
	int func(int n)
	{
		int sum = 0;
		
		// 기저사례
		if(n == 1)  return 1;
		
		// 사람 고르기
		for(int i = 0; i < MAX; ++i)
		{
			// 아직 사용되지 않았다면..
			if(!visited[i])
			{
				vistied[i] = true;
				sum += func(n - 1);
				visited[i] = false;
			}
		}
		
		return sum;
	}

```

  위의 코드에서 가장 핵심적인 부분은 for문이다. 여기서 실제로 문제를 나누고, 하나를 해결(선택)한 뒤 나머지를 재귀함수 형태로 해결한다. 여기서 하나를 해결한다는 것의 의미는 한명을 선택하는 것을 의미하고 그것이 visited[i] = true로 표현된다. 그리고 재귀함수 형태로 나머지를 해결하는 부분은 sum += func(n - 1)로 표현된다. 

  visited[i]는 i번째의 사람이 사용됐는지를 bool 값으로 표현한 것이다. 그리고 func(n - 1)은 n - 1명을 나열하는 모든 경우의 수를 의미한다. 또한, i가 바뀜에 따라 아직 선택되지 않은 인원의 구성이 바뀌어 n - 1명을 나열하는 경우의 수가 달라지게 된다. 따라서, i가 바뀜에 따라 달라지는 경우의 수를 각각 합쳐주어야 한다. 그것이 sum 변수가 의미하는 것이다. 아래의 그림을 통해 확인해보자.

<img src="./img/완전탐색_1.png" alt="이미지1" style="zoom:75%;" />

  위의 그림에서 첫번째 사람을 누구를 고르느냐에 따라 남은 인원의 구성이 바뀌어 다른 경우들을 생성한다. 따라서, i가 바뀜에 따라 발생하는 경우들은 모두 다르기에 각 경우들을 모두 sum 변수에 합쳐주어야 한다. 다음과 같이 나누어 생각해보면 쉽게 이해할 수 있다.

``` C
	
	// i 선택
	visited[i] = true;
	// i를 선택했을 경우 뒤따라오는 경우를 센다.
	temp = func(n - 1);
	// i를 선택에 따른 경우의 수를 총 경우의 수에 합친다.
	sum  = sum + temp;
	// i 선택을 해제한다.
	visited[i] = false;

```

### 3.3. 요약
--------------------------------------------------------------------------------
  * 가능한 모든 답의 후보를 만드는 과정을 여러 개의 선택으로 나눈다.
  * 그 중 하나의 조각을 선택해 답의 일부를 만들고, 나머지 답을 재귀 호출을 통해 완성한다.
  * 조각이 하나밖에 남지 않은 경우, 답을 생성했으므로 기저사례로 처리한다.